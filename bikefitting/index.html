<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bikefit MVP (BOK + TYŁ) – DEMO v3</title>
<style>
  body{margin:0;font-family:system-ui,Arial;background:#0b0b0c;color:#fff}
  header{padding:12px 16px;background:#141416;border-bottom:1px solid #26262a}
  h1{margin:0 0 8px 0;font-size:18px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:8px 0}
  input,select,button{padding:8px;border-radius:10px;border:1px solid #333;background:#0f0f11;color:#fff}
  input{width:150px}
  button{cursor:pointer}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #333;background:#0f0f11}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px}
  .card{background:#141416;border:1px solid #26262a;border-radius:12px;padding:12px}
  .full{grid-column:1/-1}
  video,canvas{width:100%;border-radius:12px;background:#000;margin-top:8px}
  pre{white-space:pre-wrap;background:#0f0f11;padding:8px;border-radius:10px;border:1px solid #26262a;max-height:220px;overflow:auto}
  #reco .item{padding:10px;border:1px solid #2a2a2f;border-radius:12px;margin:8px 0;background:#101014}
  #reco .bad{border-color:#6a2a2a}
  #reco .warn{border-color:#6a5a2a}
  #reco .ok{border-color:#2a6a3a}
  small{opacity:.8}
  .muted{opacity:.75}
  .kpi{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
  .kpi .pill{border-color:#2a2a2f}

  .sessionBar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .sessionList{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  .snap{border:1px solid #2a2a2f;border-radius:12px;background:#101014;padding:10px}
  .snapHeader{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .tag{padding:4px 8px;border-radius:999px;border:1px solid #2a2a2f;background:#0f0f11;font-size:12px}

  .demoGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px}
  .demoBox{border:1px solid #2a2a2f;border-radius:12px;background:#101014;padding:10px}
  .demoBox h3{margin:0 0 8px 0;font-size:14px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

  .timeline{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  .step{border:1px solid #2a2a2f;border-radius:12px;background:#101014;padding:10px}
  .stepTop{display:flex;justify-content:space-between;flex-wrap:wrap;gap:10px}
  .stepBtns{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btnGhost{border-color:#2a2a2f}
  .btnGood{border-color:#2a6a3a}
  .btnWarn{border-color:#6a5a2a}
  .btnBad{border-color:#6a2a2a}

  /* Client mode */
  body.client header,
  body.client #cardSide,
  body.client #cardRear,
  body.client #cardDemo pre,
  body.client #sessionList details,
  body.client #debugNote { display:none !important; }

  body.client main.grid{grid-template-columns:1fr}
  body.client .card{border-radius:16px}
  body.client .kpi{justify-content:center}
  body.client .kpi .pill{font-size:18px;padding:10px 14px}
  body.client #reco .item{font-size:18px}
  body.client #reco .item small{font-size:14px}
</style>
</head>

<body>
<header>
  <h1>Bikefit MVP (BOK + TYŁ) – DEMO v3</h1>

  <div class="row">
    <label>Tryb:</label>
    <select id="mode">
      <option value="hub">HUB (Laptop)</option>
      <option value="cam_side">CAM – BOK (Telefon)</option>
      <option value="cam_rear">CAM – TYŁ (Telefon)</option>
      <option value="demo">DEMO (bez kamer)</option>
    </select>
    <span id="status" class="pill">OFFLINE</span>
    <span id="cams" class="pill">SIDE: - | REAR: -</span>
    <button id="btnClient" class="btnGhost">Tryb klienta: OFF</button>
  </div>

  <div class="row" id="debugNote">
    <label>Room:</label><input id="room" value="default"/>
    <label>WS URL:</label><input id="wsUrl" placeholder="ws://IP:8181"/>
    <button id="btnConnect">Połącz</button>
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
  </div>

  <div class="row">
    <label>Styl:</label>
    <select id="style">
      <option value="road">Szosa</option>
      <option value="mtb">MTB</option>
    </select>
    <label>Wzrost (cm):</label><input id="height" type="number" value="175"/>
    <label>Przekrok (cm):</label><input id="inseam" type="number" value="82"/>
    <small>Tip: przekrok = od kroku do ziemi (książka + ściana).</small>
  </div>

  <div class="kpi">
    <span class="pill" id="kpiKnee">Kolano: -</span>
    <span class="pill" id="kpiElbow">Łokieć: -</span>
    <span class="pill" id="kpiRock">Rocking: -</span>
  </div>
</header>

<main class="grid">
  <section class="card" id="cardCam">
    <h2 id="camTitle">Kamera</h2>
    <div class="row">
      <button id="btnSwitchCam">Przełącz kamerę</button>
      <span class="pill" id="rolePill">ROLE: -</span>
    </div>
    <video id="v" playsinline autoplay muted></video>
    <canvas id="c"></canvas>
    <pre id="camOut"></pre>
  </section>

  <section class="card" id="cardSide">
    <h2>BOK – metryki</h2>
    <canvas id="sideCanvas"></canvas>
    <pre id="sideOut"></pre>
  </section>

  <section class="card" id="cardRear">
    <h2>TYŁ – metryki</h2>
    <canvas id="rearCanvas"></canvas>
    <pre id="rearOut"></pre>
  </section>

  <section class="card full">
    <h2>Rekomendacje</h2>
    <div id="reco"></div>
    <small class="muted">
      DEMO v3: możesz zrobić PRZED → AUTO-PO → PO i dodać kroki do timeline.
    </small>
  </section>

  <section class="card full">
    <h2>Sesja</h2>
    <div class="sessionBar">
      <button id="btnNewSession">Nowa sesja</button>
      <button id="btnSnap">Zapisz pomiar (SNAP)</button>
      <button id="btnExport">Eksport JSON</button>
      <span class="pill" id="sessionInfo">SNAP: 0</span>
      <span class="pill" id="sessionId">ID: -</span>
    </div>
    <div id="sessionList" class="sessionList"></div>
    <small class="muted">Eksport zapisuje snapshoty metryk + rekomendacje.</small>
  </section>

  <!-- DEMO v3 -->
  <section class="card full" id="cardDemo">
    <h2>DEMO v3 – AUTO-PO + timeline</h2>

    <div class="row">
      <label>Scenariusz:</label>
      <select id="demoScenario">
        <option value="ok">OK (referencja)</option>
        <option value="saddle_high">Siodło za wysoko</option>
        <option value="saddle_low">Siodło za nisko</option>
        <option value="reach_long">Za długi reach</option>
        <option value="pelvis_asym">Asymetria miednicy</option>
        <option value="shoulder_asym">Asymetria barków</option>
        <option value="rocking_high">Mocny rocking</option>
      </select>
      <button id="btnDemoLoad">Wczytaj</button>

      <span class="pill" id="demoStatePill">LIVE</span>
      <button id="btnSetBefore" class="btnWarn">Ustaw jako PRZED</button>
      <button id="btnAutoAfter" class="btnGood">AUTO-PO (z rekomendacji)</button>
      <button id="btnSetAfter" class="btnWarn">Ustaw jako PO</button>
      <button id="btnClearBeforeAfter" class="btnGhost">Wyczyść PRZED/PO</button>
    </div>

    <div class="row">
      <label>Korekty DEMO (ręczne):</label>
      <button id="btnAdjSaddleDown">Siodło -5mm</button>
      <button id="btnAdjSaddleUp">Siodło +5mm</button>
      <button id="btnAdjReachShorter">Reach -10mm</button>
      <button id="btnAdjReachLonger">Reach +10mm</button>
      <button id="btnAdjReduceRock">Zredukuj rocking</button>
    </div>

    <div class="row">
      <label>Timeline:</label>
      <button id="btnTLAdd" class="btnGhost">Dodaj krok</button>
      <button id="btnTLAddBefore" class="btnWarn">Dodaj PRZED</button>
      <button id="btnTLAddAfter" class="btnGood">Dodaj PO</button>
      <button id="btnTLClear" class="btnBad">Wyczyść timeline</button>
    </div>

    <div class="demoGrid">
      <div class="demoBox">
        <h3>PRZED – metryki</h3>
        <pre class="mono" id="demoBeforeOut">brak</pre>
      </div>
      <div class="demoBox">
        <h3>PO – metryki</h3>
        <pre class="mono" id="demoAfterOut">brak</pre>
      </div>
      <div class="demoBox">
        <h3>Różnice (PO - PRZED)</h3>
        <pre class="mono" id="demoDeltaOut">brak</pre>
      </div>
      <div class="demoBox">
        <h3>LIVE – punkty</h3>
        <pre class="mono" id="demoJson">-</pre>
      </div>
    </div>

    <div class="timeline" id="timeline"></div>
  </section>
</main>

<script>
/** =========================
 *  Utils + punkty DEMO
 *  ========================= */
function deepClone(obj){ return JSON.parse(JSON.stringify(obj)); }
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

function angle3(a,b,c){
  if(!a||!b||!c) return NaN;
  const ba={x:a.x-b.x, y:a.y-b.y};
  const bc={x:c.x-b.x, y:c.y-b.y};
  const dot=ba.x*bc.x+ba.y*bc.y;
  const nba=Math.hypot(ba.x,ba.y);
  const nbc=Math.hypot(bc.x,bc.y);
  const cos=dot/(nba*nbc+1e-9);
  const v=Math.max(-1,Math.min(1,cos));
  return Math.acos(v)*180/Math.PI;
}

/** =========================
 *  Reco v1.1 (progowe)
 *  ========================= */
function makeTargets(style){
  return style==="road"
    ? { kneeBDP: [145, 160], elbow: [150, 175], rockingMax: 0.035 }
    : { kneeBDP: [140, 158], elbow: [155, 178], rockingMax: 0.045 };
}
function stepMmFromDelta(deltaDeg){
  const ad = Math.abs(deltaDeg);
  if(ad < 2) return 0;
  if(ad < 4) return 3;
  if(ad < 7) return 5;
  if(ad < 10) return 10;
  return 15;
}
function saddleStarterFromInseam(inseam_cm){
  if(!inseam_cm || inseam_cm<=0) return null;
  return 0.883 * inseam_cm;
}
function recommendations(profile, sideMetrics, rearMetrics){
  const t = makeTargets(profile.style);
  const out = [];

  const starter = saddleStarterFromInseam(profile.inseam_cm||0);
  out.push({
    lvl:"ok",
    title:"Profil",
    why:`Styl: ${profile.style.toUpperCase()}, wzrost: ${profile.height_cm||"-"} cm, przekrok: ${profile.inseam_cm||"-"} cm.`,
    do: starter ? `Punkt startowy (orientacyjnie): wysokość siodła ~ ${starter.toFixed(1)} cm (0.883).` : `Dodaj przekrok, a policzę punkt startowy siodła.`
  });

  // siodło (kolano + rocking)
  if(Number.isFinite(sideMetrics.knee)){
    const knee = sideMetrics.knee;
    const deltaHigh = knee - t.kneeBDP[1];
    const deltaLow  = t.kneeBDP[0] - knee;
    const mmHigh = stepMmFromDelta(deltaHigh) || 5;
    const mmLow  = stepMmFromDelta(deltaLow)  || 5;

    if(knee > t.kneeBDP[1] && Number.isFinite(rearMetrics.rocking) && rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"bad", title:"Siodło prawdopodobnie za wysoko",
        why:`Kolano ~ ${knee.toFixed(1)}° (cel: ${t.kneeBDP[0]}–${t.kneeBDP[1]}°) + rocking ${rearMetrics.rocking.toFixed(3)} (wysoki).`,
        do:`Obniż siodło o ${mmHigh} mm i re-test.`});
    } else if(knee > t.kneeBDP[1]){
      out.push({lvl:"warn", title:"Możliwe: siodło za wysoko",
        why:`Kolano ~ ${knee.toFixed(1)}° (powyżej ${t.kneeBDP[1]}°).`,
        do:`Test: obniż o ${mmHigh} mm i re-test.`});
    } else if(knee < t.kneeBDP[0]){
      out.push({lvl:"warn", title:"Możliwe: siodło za nisko",
        why:`Kolano ~ ${knee.toFixed(1)}° (poniżej ${t.kneeBDP[0]}°).`,
        do:`Test: podnieś o ${mmLow} mm i re-test.`});
    } else {
      out.push({lvl:"ok", title:"Wysokość siodła wygląda OK (wg kolana)",
        why:`Kolano ~ ${knee.toFixed(1)}° w zakresie.`,
        do:`OK. Dalej przód + stabilność.`});
    }
  } else {
    out.push({lvl:"warn", title:"Brak metryki kolana (BOK)",
      why:"Nie wykryto hip/knee/ankle.", do:"Sprawdź markery/światło."});
  }

  // reach
  if(Number.isFinite(sideMetrics.elbow)){
    const t = makeTargets(profile.style);
    const e = sideMetrics.elbow;
    if(e > t.elbow[1]){
      out.push({lvl:"warn", title:"Możliwie za duży reach",
        why:`Łokieć ~ ${e.toFixed(1)}° (powyżej ${t.elbow[1]}°).`,
        do:`Test: krótszy mostek o 10 mm lub +5–10 mm podkładek. Re-test.`});
    } else if(e < t.elbow[0]){
      out.push({lvl:"warn", title:"Pozycja mocno zebrana",
        why:`Łokieć ~ ${e.toFixed(1)}° (poniżej ${t.elbow[0]}°).`,
        do:`Jeśli nie aero: dłuższy mostek +10 mm. Re-test.`});
    } else {
      out.push({lvl:"ok", title:"Łokieć wygląda OK", why:`Łokieć ~ ${e.toFixed(1)}° w zakresie.`, do:"OK."});
    }
  }

  // rocking
  if(Number.isFinite(rearMetrics.rocking)){
    const t = makeTargets(profile.style);
    if(rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"warn", title:"Rocking miednicy podwyższony",
        why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)} (powyżej ${t.rockingMax}).`,
        do:`Najczęściej: minimalnie za wysoko siodło lub zbyt agresywny przód. Testuj 1 zmianę.`});
    } else {
      out.push({lvl:"ok", title:"Stabilność miednicy OK",
        why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)}.`,
        do:"OK."});
    }
  }

  out.push({lvl:"ok", title:"Setback / sztyca (kolejna wersja)",
    why:"W v4 dołożymy KOPS i wtedy setback/offset będą precyzyjne.",
    do:"Na teraz: wysokość siodła + reach + stabilność."});

  return out;
}

/** =========================
 *  Metryki z punktów
 *  ========================= */
function computeSideMetrics(points){
  const m = { knee: NaN, hip: NaN, elbow: NaN };
  if(points?.hip && points?.knee && points?.ankle) m.knee = angle3(points.hip, points.knee, points.ankle);
  if(points?.shoulder && points?.hip && points?.knee) m.hip = angle3(points.shoulder, points.hip, points.knee);
  if(points?.shoulder && points?.elbow && points?.wrist) m.elbow = angle3(points.shoulder, points.elbow, points.wrist);
  return m;
}
let rearHistory = [];
function computeRearMetrics(points){
  const m = { rocking: NaN, pelvisTilt: NaN, shoulderTilt: NaN };

  if(points?.l_pelvis && points?.r_pelvis){
    m.pelvisTilt = points.l_pelvis.y - points.r_pelvis.y;
  }
  if(points?.l_shoulder && points?.r_shoulder){
    m.shoulderTilt = points.l_shoulder.y - points.r_shoulder.y;
  }

  if(points?.l_pelvis && points?.r_pelvis && points?.l_shoulder && points?.r_shoulder){
    const pelvisMid = { x:(points.l_pelvis.x+points.r_pelvis.x)/2, y:(points.l_pelvis.y+points.r_pelvis.y)/2 };
    const shoulderMid= { x:(points.l_shoulder.x+points.r_shoulder.x)/2, y:(points.l_shoulder.y+points.r_shoulder.y)/2 };
    const torsoH = Math.max(50, Math.abs(pelvisMid.y - shoulderMid.y));
    const tiltNorm = Math.abs(m.pelvisTilt) / torsoH;

    rearHistory.push(tiltNorm);
    if(rearHistory.length>120) rearHistory.shift();

    const max = Math.max(...rearHistory);
    const min = Math.min(...rearHistory);
    m.rocking = (max - min);
  }
  return m;
}

/** =========================
 *  DOM
 *  ========================= */
const els = {
  mode: document.getElementById("mode"),
  status: document.getElementById("status"),
  cams: document.getElementById("cams"),
  room: document.getElementById("room"),
  wsUrl: document.getElementById("wsUrl"),
  btnConnect: document.getElementById("btnConnect"),
  btnStart: document.getElementById("btnStart"),
  btnStop: document.getElementById("btnStop"),
  btnClient: document.getElementById("btnClient"),

  style: document.getElementById("style"),
  height: document.getElementById("height"),
  inseam: document.getElementById("inseam"),

  kpiKnee: document.getElementById("kpiKnee"),
  kpiElbow: document.getElementById("kpiElbow"),
  kpiRock: document.getElementById("kpiRock"),

  cardCam: document.getElementById("cardCam"),

  // reco
  reco: document.getElementById("reco"),

  // session
  btnNewSession: document.getElementById("btnNewSession"),
  btnSnap: document.getElementById("btnSnap"),
  btnExport: document.getElementById("btnExport"),
  sessionInfo: document.getElementById("sessionInfo"),
  sessionId: document.getElementById("sessionId"),
  sessionList: document.getElementById("sessionList"),

  // demo
  demoScenario: document.getElementById("demoScenario"),
  btnDemoLoad: document.getElementById("btnDemoLoad"),
  demoStatePill: document.getElementById("demoStatePill"),
  btnSetBefore: document.getElementById("btnSetBefore"),
  btnAutoAfter: document.getElementById("btnAutoAfter"),
  btnSetAfter: document.getElementById("btnSetAfter"),
  btnClearBeforeAfter: document.getElementById("btnClearBeforeAfter"),

  btnAdjSaddleDown: document.getElementById("btnAdjSaddleDown"),
  btnAdjSaddleUp: document.getElementById("btnAdjSaddleUp"),
  btnAdjReachShorter: document.getElementById("btnAdjReachShorter"),
  btnAdjReachLonger: document.getElementById("btnAdjReachLonger"),
  btnAdjReduceRock: document.getElementById("btnAdjReduceRock"),

  btnTLAdd: document.getElementById("btnTLAdd"),
  btnTLAddBefore: document.getElementById("btnTLAddBefore"),
  btnTLAddAfter: document.getElementById("btnTLAddAfter"),
  btnTLClear: document.getElementById("btnTLClear"),
  timeline: document.getElementById("timeline"),

  demoBeforeOut: document.getElementById("demoBeforeOut"),
  demoAfterOut: document.getElementById("demoAfterOut"),
  demoDeltaOut: document.getElementById("demoDeltaOut"),
  demoJson: document.getElementById("demoJson"),
};

els.wsUrl.value = `ws://${location.hostname || "127.0.0.1"}:8181`;

/** =========================
 *  State
 *  ========================= */
let ws = null;
let running = false;
let clientMode = false;

let sidePoints = null;
let rearPoints = null;

let demoBefore = null;
let demoAfter  = null;

let timeline = []; // steps: {t,label,profile,metrics,reco,points}

/** =========================
 *  UI helpers
 *  ========================= */
function profile(){
  return {
    style: els.style.value,
    height_cm: Number(els.height.value||0),
    inseam_cm: Number(els.inseam.value||0)
  };
}
function setStatus(text, ok){
  els.status.textContent = text;
  els.status.style.borderColor = ok ? "#2a6a3a" : "#6a2a2a";
}
function setCams(online){
  els.cams.textContent = `SIDE: ${online.side ? "ON" : "-"} | REAR: ${online.rear ? "ON" : "-"}`;
}
function setKpi(sideM, rearM){
  els.kpiKnee.textContent = `Kolano: ${Number.isFinite(sideM.knee) ? sideM.knee.toFixed(1)+"°" : "-"}`;
  els.kpiElbow.textContent = `Łokieć: ${Number.isFinite(sideM.elbow) ? sideM.elbow.toFixed(1)+"°" : "-"}`;
  els.kpiRock.textContent = `Rocking: ${Number.isFinite(rearM.rocking) ? rearM.rocking.toFixed(3) : "-"}`;
}
function renderReco(sideM, rearM){
  const items = recommendations(profile(), sideM, rearM);
  const top = clientMode ? items.slice(0,3) : items;
  els.reco.innerHTML = top.map(it => `
    <div class="item ${it.lvl}">
      <div><b>${it.title}</b></div>
      <div><small>${it.why}</small></div>
      <div>${it.do}</div>
    </div>
  `).join("");
  return items;
}

function fmtM(m){
  return {
    knee: Number.isFinite(m.knee) ? Number(m.knee.toFixed(2)) : null,
    elbow: Number.isFinite(m.elbow) ? Number(m.elbow.toFixed(2)) : null,
    rocking: Number.isFinite(m.rocking) ? Number(m.rocking.toFixed(4)) : null,
  };
}

/** =========================
 *  DEMO presets
 *  ========================= */
const DEMO_PRESETS = {
  ok: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
  },
  saddle_high: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:610,y:520}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:345}, r_pelvis:{x:500,y:390} }
  },
  saddle_low: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:430}, ankle:{x:550,y:590}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:450,y:370}, r_pelvis:{x:490,y:372} }
  },
  reach_long: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:235,y:215}, wrist:{x:145,y:215} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
  },
  pelvis_asym: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:340}, r_pelvis:{x:500,y:395} }
  },
  shoulder_asym: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:185}, r_shoulder:{x:520,y:220}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
  },
  rocking_high: {
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:600,y:520}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:330}, r_pelvis:{x:500,y:410} }
  }
};

function demoLoadScenario(key){
  const preset = DEMO_PRESETS[key] || DEMO_PRESETS.ok;
  sidePoints = deepClone(preset.side);
  rearPoints = deepClone(preset.rear);
  rearHistory = [];
  els.demoStatePill.textContent = `LIVE (${key})`;
  updateAll();
}

/** =========================
 *  DEMO "korekty" – symulacje
 *  ========================= */
function adjSaddle(mm){
  // mm -> px w DEMO (umownie)
  const px = mm * 1.2;
  if(sidePoints?.ankle) sidePoints.ankle.y += px;
  if(sidePoints?.knee)  sidePoints.knee.y  += px*0.4;
  if(rearPoints?.l_pelvis && rearPoints?.r_pelvis){
    rearPoints.l_pelvis.y += px*0.2;
    rearPoints.r_pelvis.y += px*0.2;
  }
}
function adjReach(mm){
  const px = mm * 1.0;
  if(sidePoints?.wrist) sidePoints.wrist.x += px;
  if(sidePoints?.elbow) sidePoints.elbow.x += px*0.6;
}
function reduceRocking(){
  if(rearPoints?.l_pelvis && rearPoints?.r_pelvis){
    const mid = (rearPoints.l_pelvis.y + rearPoints.r_pelvis.y) / 2;
    rearPoints.l_pelvis.y = mid - 2;
    rearPoints.r_pelvis.y = mid + 2;
  }
}

/** =========================
 *  AUTO-PO: decyzja z metryk
 *  ========================= */
function autoActionsFromMetrics(p, sideM, rearM){
  const t = makeTargets(p.style);
  const actions = [];

  // Siodło: jeśli kolano za prosto -> obniż; jeśli za mocno ugięte -> podnieś
  if(Number.isFinite(sideM.knee)){
    if(sideM.knee > t.kneeBDP[1]){
      const mm = stepMmFromDelta(sideM.knee - t.kneeBDP[1]) || 5;
      actions.push({type:"saddle", mm:+mm}); // w DEMO: +mm => "w dół nogi", czyli siodło w dół
    } else if(sideM.knee < t.kneeBDP[0]){
      const mm = stepMmFromDelta(t.kneeBDP[0] - sideM.knee) || 5;
      actions.push({type:"saddle", mm:-mm}); // "w górę"
    }
  }

  // Reach: jeśli łokieć za prosty -> skróć reach; jeśli za mocno ugięty -> wydłuż
  if(Number.isFinite(sideM.elbow)){
    if(sideM.elbow > t.elbow[1]){
      actions.push({type:"reach", mm:+10}); // skróć reach o 10mm (w DEMO: +mm przesuwa rękę "do środka")
    } else if(sideM.elbow < t.elbow[0]){
      actions.push({type:"reach", mm:-10}); // wydłuż
    }
  }

  // Rocking: jeśli za duży, spróbuj redukcji
  if(Number.isFinite(rearM.rocking) && rearM.rocking > t.rockingMax){
    actions.push({type:"rocking", on:true});
  }

  // Priorytet: jedna zmiana naraz? -> w DEMO robimy max 2 akcje + rocking
  const out = [];
  for(const a of actions){
    if(a.type==="rocking"){ out.push(a); continue; }
    if(out.filter(x=>x.type!=="rocking").length < 2) out.push(a);
  }
  return out;
}

function applyActions(actions){
  for(const a of actions){
    if(a.type==="saddle") adjSaddle(a.mm);
    if(a.type==="reach")  adjReach(a.mm);
    if(a.type==="rocking") reduceRocking();
  }
}

/** =========================
 *  PRZED/PO + porównanie
 *  ========================= */
function metricsForState(state){
  const sideM = computeSideMetrics(state?.side);
  const rearM = computeRearMetrics(state?.rear);
  return { side: sideM, rear: rearM };
}
function renderBeforeAfter(){
  if(demoBefore){
    const mb = metricsForState(demoBefore);
    els.demoBeforeOut.textContent = JSON.stringify({ side: fmtM(mb.side), rear: fmtM(mb.rear) }, null, 2);
  } else els.demoBeforeOut.textContent = "brak";

  if(demoAfter){
    const ma = metricsForState(demoAfter);
    els.demoAfterOut.textContent = JSON.stringify({ side: fmtM(ma.side), rear: fmtM(ma.rear) }, null, 2);
  } else els.demoAfterOut.textContent = "brak";

  if(demoBefore && demoAfter){
    const mb = metricsForState(demoBefore);
    const ma = metricsForState(demoAfter);
    const d = {
      knee: (Number.isFinite(ma.side.knee) && Number.isFinite(mb.side.knee)) ? Number((ma.side.knee - mb.side.knee).toFixed(2)) : null,
      elbow:(Number.isFinite(ma.side.elbow) && Number.isFinite(mb.side.elbow)) ? Number((ma.side.elbow - mb.side.elbow).toFixed(2)) : null,
      rocking:(Number.isFinite(ma.rear.rocking) && Number.isFinite(mb.rear.rocking)) ? Number((ma.rear.rocking - mb.rear.rocking).toFixed(4)) : null
    };
    els.demoDeltaOut.textContent = JSON.stringify(d, null, 2);
  } else els.demoDeltaOut.textContent = "brak";
}

function setBefore(){
  demoBefore = { side: deepClone(sidePoints), rear: deepClone(rearPoints) };
  els.demoStatePill.textContent = `LIVE (PRZED ustawione)`;
  renderBeforeAfter();
}
function setAfter(){
  demoAfter = { side: deepClone(sidePoints), rear: deepClone(rearPoints) };
  els.demoStatePill.textContent = `LIVE (PO ustawione)`;
  renderBeforeAfter();
}
function clearBeforeAfter(){
  demoBefore = null; demoAfter = null;
  els.demoStatePill.textContent = `LIVE`;
  els.demoBeforeOut.textContent = "brak";
  els.demoAfterOut.textContent = "brak";
  els.demoDeltaOut.textContent = "brak";
}

/** =========================
 *  Timeline (kroki)
 *  ========================= */
function addTimelineStep(label){
  const p = profile();
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);
  const reco = recommendations(p, sideM, rearM);

  timeline.push({
    t: new Date().toISOString(),
    label,
    profile: p,
    metrics: { side: fmtM(sideM), rear: fmtM(rearM) },
    reco,
    points: { side: deepClone(sidePoints), rear: deepClone(rearPoints) }
  });
  renderTimeline();
}
function renderTimeline(){
  els.timeline.innerHTML = timeline.map((s, idx) => `
    <div class="step">
      <div class="stepTop">
        <div><b>Krok #${idx+1}: ${s.label}</b> <span class="tag">${new Date(s.t).toLocaleString()}</span></div>
        <div class="tag">${s.profile.style.toUpperCase()}</div>
      </div>
      <div class="muted">Kolano: ${s.metrics.side.knee ?? "-"} | Łokieć: ${s.metrics.side.elbow ?? "-"} | Rocking: ${s.metrics.rear.rocking ?? "-"}</div>
      <div class="stepBtns">
        <button class="btnGhost" data-act="load" data-i="${idx}">Wczytaj ten krok</button>
        <button class="btnGhost" data-act="export" data-i="${idx}">Eksport kroku JSON</button>
      </div>
    </div>
  `).join("");

  els.timeline.querySelectorAll("button[data-act]").forEach(btn=>{
    btn.onclick = () => {
      const i = Number(btn.dataset.i);
      const act = btn.dataset.act;
      const step = timeline[i];
      if(!step) return;

      if(act==="load"){
        sidePoints = deepClone(step.points.side);
        rearPoints = deepClone(step.points.rear);
        rearHistory = [];
        els.demoStatePill.textContent = `LIVE (wczytano: ${step.label})`;
        updateAll();
      }
      if(act==="export"){
        downloadJson(`TL_STEP_${i+1}_${step.label.replace(/\s+/g,"_")}.json`, step);
      }
    };
  });
}
function clearTimeline(){
  timeline = [];
  renderTimeline();
}

/** =========================
 *  Główna aktualizacja UI (bez kamer)
 *  ========================= */
function updateAll(){
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);

  setKpi(sideM, rearM);
  renderReco(sideM, rearM);

  els.demoJson.textContent = JSON.stringify({ side: sidePoints, rear: rearPoints }, null, 2);
  renderBeforeAfter();
}

/** =========================
 *  Session export (jak było)
 *  ========================= */
let session = { id:null, createdAt:null, snaps:[] };
function newSession(){
  session = {
    id: `S-${Math.random().toString(16).slice(2,8)}-${Date.now().toString(16).slice(-6)}`.toUpperCase(),
    createdAt: new Date().toISOString(),
    snaps: []
  };
  renderSession();
}
function renderSession(){
  els.sessionInfo.textContent = `SNAP: ${session.snaps.length}`;
  els.sessionId.textContent = `ID: ${session.id || "-"}`;
  els.sessionList.innerHTML = session.snaps.map((s,idx)=>`
    <div class="snap">
      <div class="snapHeader">
        <div><b>SNAP #${idx+1}</b> <span class="tag">${new Date(s.t).toLocaleString()}</span></div>
        <div class="tag">${s.profile.style.toUpperCase()}</div>
      </div>
      <div class="muted">Kolano: ${s.side.knee ?? "-"} | Łokieć: ${s.side.elbow ?? "-"} | Rocking: ${s.rear.rocking ?? "-"}</div>
      <details>
        <summary>Rekomendacje (${s.reco.length})</summary>
        <div style="margin-top:8px">${s.reco.map(r=>`<div class="item ${r.lvl}"><b>${r.title}</b><div class="muted">${r.why}</div><div>${r.do}</div></div>`).join("")}</div>
      </details>
    </div>
  `).join("");
}
function downloadJson(filename, obj){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

/** =========================
 *  Tryb klienta
 *  ========================= */
function toggleClient(){
  clientMode = !clientMode;
  document.body.classList.toggle("client", clientMode);
  els.btnClient.textContent = `Tryb klienta: ${clientMode ? "ON" : "OFF"}`;
  updateAll();
}

/** =========================
 *  Wire events
 *  ========================= */
els.btnClient.onclick = () => toggleClient();

els.btnNewSession.onclick = () => newSession();
els.btnSnap.onclick = () => {
  const p = profile();
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);
  const reco = recommendations(p, sideM, rearM);

  session.snaps.push({
    t: new Date().toISOString(),
    profile: p,
    side: fmtM(sideM),
    rear: fmtM(rearM),
    points: { side: deepClone(sidePoints), rear: deepClone(rearPoints) },
    reco
  });
  renderSession();
};
els.btnExport.onclick = () => {
  if(!session.id) newSession();
  downloadJson(`${session.id}.json`, session);
};

els.btnDemoLoad.onclick = () => demoLoadScenario(els.demoScenario.value);
els.btnSetBefore.onclick = () => setBefore();
els.btnSetAfter.onclick = () => setAfter();
els.btnClearBeforeAfter.onclick = () => clearBeforeAfter();

// ręczne korekty
els.btnAdjSaddleDown.onclick = () => { adjSaddle(+5); updateAll(); };
els.btnAdjSaddleUp.onclick   = () => { adjSaddle(-5); updateAll(); };
els.btnAdjReachShorter.onclick = () => { adjReach(+10); updateAll(); };
els.btnAdjReachLonger.onclick  = () => { adjReach(-10); updateAll(); };
els.btnAdjReduceRock.onclick   = () => { reduceRocking(); updateAll(); };

// AUTO-PO
els.btnAutoAfter.onclick = () => {
  // bazujemy na aktualnym LIVE
  const p = profile();
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);
  const actions = autoActionsFromMetrics(p, sideM, rearM);

  // jeżeli nie ma PRZED, ustaw je automatycznie
  if(!demoBefore) setBefore();

  applyActions(actions);
  rearHistory = [];
  updateAll();

  // ustaw PO automatycznie
  setAfter();

  // dodaj do timeline
  addTimelineStep(`AUTO-PO (${actions.map(a=>a.type+(a.mm?` ${a.mm}mm`:"")).join(", ") || "brak zmian"})`);
};

// timeline
els.btnTLAdd.onclick = () => addTimelineStep("Krok (LIVE)");
els.btnTLAddBefore.onclick = () => {
  if(!demoBefore) return alert("Najpierw ustaw PRZED.");
  const step = {
    t: new Date().toISOString(),
    label: "PRZED",
    profile: profile(),
    metrics: (()=>{ const m = metricsForState(demoBefore); return {side:fmtM(m.side), rear:fmtM(m.rear)}; })(),
    reco: (()=>{ const m = metricsForState(demoBefore); return recommendations(profile(), m.side, m.rear); })(),
    points: { side: deepClone(demoBefore.side), rear: deepClone(demoBefore.rear) }
  };
  timeline.push(step);
  renderTimeline();
};
els.btnTLAddAfter.onclick = () => {
  if(!demoAfter) return alert("Najpierw ustaw PO.");
  const step = {
    t: new Date().toISOString(),
    label: "PO",
    profile: profile(),
    metrics: (()=>{ const m = metricsForState(demoAfter); return {side:fmtM(m.side), rear:fmtM(m.rear)}; })(),
    reco: (()=>{ const m = metricsForState(demoAfter); return recommendations(profile(), m.side, m.rear); })(),
    points: { side: deepClone(demoAfter.side), rear: deepClone(demoAfter.rear) }
  };
  timeline.push(step);
  renderTimeline();
};
els.btnTLClear.onclick = () => clearTimeline();

/** =========================
 *  Mode behavior
 *  ========================= */
function applyMode(){
  const m = els.mode.value;
  const isCam = (m==="cam_side" || m==="cam_rear");
  const isDemo= (m==="demo");
  els.cardCam.style.display = isCam ? "" : "none";

  // W DEMO i HUB pokazujemy UI analityczne (w client mode i tak się ukryje)
  document.getElementById("cardSide").style.display = (isDemo || m==="hub") ? "" : "none";
  document.getElementById("cardRear").style.display = (isDemo || m==="hub") ? "" : "none";
  document.getElementById("cardDemo").style.display = isDemo ? "" : "none";

  if(isDemo) updateAll();
}
els.mode.onchange = applyMode;

/** =========================
 *  INIT
 *  ========================= */
(function init(){
  newSession();
  demoLoadScenario("ok");
  clearBeforeAfter();
  applyMode();
  renderTimeline();
  updateAll();
})();
</script>
</body>
</html>
