<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bikefit MVP (BOK + TYŁ) – 1 plik</title>
<style>
  body{margin:0;font-family:system-ui,Arial;background:#0b0b0c;color:#fff}
  header{padding:12px 16px;background:#141416;border-bottom:1px solid #26262a}
  h1{margin:0 0 8px 0;font-size:18px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:8px 0}
  input,select,button{padding:8px;border-radius:10px;border:1px solid #333;background:#0f0f11;color:#fff}
  input{width:150px}
  button{cursor:pointer}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #333;background:#0f0f11}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px}
  .card{background:#141416;border:1px solid #26262a;border-radius:12px;padding:12px}
  .full{grid-column:1/-1}
  video,canvas{width:100%;border-radius:12px;background:#000;margin-top:8px}
  pre{white-space:pre-wrap;background:#0f0f11;padding:8px;border-radius:10px;border:1px solid #26262a;max-height:220px;overflow:auto}
  #reco .item{padding:10px;border:1px solid #2a2a2f;border-radius:12px;margin:8px 0;background:#101014}
  #reco .bad{border-color:#6a2a2a}
  #reco .warn{border-color:#6a5a2a}
  #reco .ok{border-color:#2a6a3a}
  small{opacity:.8}
  .muted{opacity:.75}
  .kpi{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0}
  .kpi .pill{border-color:#2a2a2f}
  .sessionBar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .sessionList{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  .snap{border:1px solid #2a2a2f;border-radius:12px;background:#101014;padding:10px}
  .snapHeader{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap}
  .tag{padding:4px 8px;border-radius:999px;border:1px solid #2a2a2f;background:#0f0f11;font-size:12px}
</style>
</head>
<body>
<header>
  <h1>Bikefit MVP (BOK + TYŁ) – 1 plik</h1>

  <div class="row">
    <label>Tryb:</label>
    <select id="mode">
      <option value="hub">HUB (Laptop)</option>
      <option value="cam_side">CAM – BOK (Telefon)</option>
      <option value="cam_rear">CAM – TYŁ (Telefon)</option>
      <option value="demo">DEMO (bez kamer)</option>
    </select>
    <span id="status" class="pill">OFFLINE</span>
    <span id="cams" class="pill">SIDE: - | REAR: -</span>
  </div>

  <div class="row">
    <label>Room:</label><input id="room" value="default"/>
    <label>WS URL:</label><input id="wsUrl" placeholder="ws://IP:8181"/>
    <button id="btnConnect">Połącz</button>
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
  </div>

  <div class="row">
    <label>Styl:</label>
    <select id="style">
      <option value="road">Szosa</option>
      <option value="mtb">MTB</option>
    </select>
    <label>Wzrost (cm):</label><input id="height" type="number" value="175"/>
    <label>Przekrok (cm):</label><input id="inseam" type="number" value="82"/>
    <small>Tip: przekrok = od kroku do ziemi (książka + ściana).</small>
  </div>

  <div class="kpi">
    <span class="pill" id="kpiKnee">Kolano: -</span>
    <span class="pill" id="kpiElbow">Łokieć: -</span>
    <span class="pill" id="kpiRock">Rocking: -</span>
  </div>
</header>

<main class="grid">
  <section class="card" id="cardCam">
    <h2 id="camTitle">Kamera</h2>
    <div class="row">
      <button id="btnSwitchCam">Przełącz kamerę</button>
      <span class="pill" id="rolePill">ROLE: -</span>
    </div>
    <video id="v" playsinline autoplay muted></video>
    <canvas id="c"></canvas>
    <pre id="camOut"></pre>
  </section>

  <section class="card" id="cardSide">
    <h2>BOK – metryki</h2>
    <canvas id="sideCanvas"></canvas>
    <pre id="sideOut"></pre>
  </section>

  <section class="card" id="cardRear">
    <h2>TYŁ – metryki</h2>
    <canvas id="rearCanvas"></canvas>
    <pre id="rearOut"></pre>
  </section>

  <section class="card full">
    <h2>Rekomendacje</h2>
    <div id="reco"></div>
    <small class="muted">
      Uwaga: v1.1 to rekomendacje krokowe (3–5 mm, 5–10 mm, 10–15 mm) + re-test.
    </small>
  </section>

  <section class="card full">
    <h2>Sesja</h2>
    <div class="sessionBar">
      <button id="btnNewSession">Nowa sesja</button>
      <button id="btnSnap">Zapisz pomiar (SNAP)</button>
      <button id="btnExport">Eksport JSON</button>
      <span class="pill" id="sessionInfo">SNAP: 0</span>
      <span class="pill" id="sessionId">ID: -</span>
    </div>
    <div id="sessionList" class="sessionList"></div>
    <small class="muted">
      Eksport zapisuje snapshoty metryk + rekomendacje. W przyszłości dołożymy PDF.
    </small>
  </section>

  <section class="card full" id="cardDemo">
    <h2>DEMO – ręczne punkty (bez kamer)</h2>
    <small>Możesz tu wkleić punkty i sprawdzić, czy rekomendacje działają zanim odpalisz kamery.</small>
    <pre id="demoJson"></pre>
    <button id="btnDemoGood">Wstaw “OK”</button>
    <button id="btnDemoBadSaddle">Wstaw “siodło za wysoko”</button>
    <button id="btnDemoBadReach">Wstaw “za długi reach”</button>
  </section>
</main>

<script>
/** =========================
 *  HSV + markery (do dopasowania pod Twoje naklejki)
 *  ========================= */
const HSV = {
  neonGreen: { h1: 45,  h2: 95,  s: 120, v: 80 },
  cyan:      { h1: 170, h2: 210, s: 120, v: 80 },
  orange:    { h1: 15,  h2: 40,  s: 120, v: 80 },
  yellow:    { h1: 40,  h2: 70,  s: 120, v: 80 },
  purple:    { h1: 250, h2: 300, s: 110, v: 70 },
  pinkWrap:  { h1: 300, h2: 360, s: 120, v: 80, wrap: true, h3: 0, h4: 20 }
};

function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  const d=max-min;
  let h=0;
  if(d!==0){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max===0?0:d/max;
  const v=max;
  return {h, s:s*255, v:v*255};
}
function inPreset(hsv,p){
  if(hsv.s<p.s || hsv.v<p.v) return false;
  if(p.wrap){
    return (hsv.h>=p.h1 && hsv.h<=p.h2) || (hsv.h>=p.h3 && hsv.h<=p.h4);
  }
  return hsv.h>=p.h1 && hsv.h<=p.h2;
}
function findCentroid(imageData, w, h, preset){
  const data=imageData.data;
  let sx=0, sy=0, c=0;
  for(let y=0;y<h;y+=2){
    for(let x=0;x<w;x+=2){
      const i=(y*w+x)*4;
      const hsv=rgbToHsv(data[i],data[i+1],data[i+2]);
      if(inPreset(hsv,preset)){ sx+=x; sy+=y; c++; }
    }
  }
  if(c<60) return null;
  return {x:sx/c, y:sy/c, n:c};
}
function angle3(a,b,c){
  if(!a||!b||!c) return NaN;
  const ba={x:a.x-b.x, y:a.y-b.y};
  const bc={x:c.x-b.x, y:c.y-b.y};
  const dot=ba.x*bc.x+ba.y*bc.y;
  const nba=Math.hypot(ba.x,ba.y);
  const nbc=Math.hypot(bc.x,bc.y);
  const cos=dot/(nba*nbc+1e-9);
  const v=Math.max(-1,Math.min(1,cos));
  return Math.acos(v)*180/Math.PI;
}
function drawDot(ctx,p,label){
  if(!p) return;
  ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.stroke();
  ctx.fillText(label,p.x+10,p.y);
}

/** =========================
 *  Reco v1.1 (krokowo + mm)
 *  ========================= */
function makeTargets(style){
  // angle3 daje kąt wewnętrzny stawu (większy = bardziej wyprostowane)
  // Progi MVP – będziemy kalibrować testami.
  return style==="road"
    ? { kneeBDP: [145, 160], elbow: [150, 175], rockingMax: 0.035 }
    : { kneeBDP: [140, 158], elbow: [155, 178], rockingMax: 0.045 };
}
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function stepMmFromDelta(deltaDeg){
  // bardzo proste mapowanie: większe odchylenie => większy krok w mm
  const ad = Math.abs(deltaDeg);
  if(ad < 2) return 0;
  if(ad < 4) return 3;
  if(ad < 7) return 5;
  if(ad < 10) return 10;
  return 15;
}
function saddleStarterFromInseam(inseam_cm){
  // LeMond: 0.883 * inseam (cm) -> wysokość siodła (środek suportu do szczytu siodła) w cm
  if(!inseam_cm || inseam_cm<=0) return null;
  return 0.883 * inseam_cm;
}

function recommendations(profile, sideMetrics, rearMetrics){
  const t = makeTargets(profile.style);
  const out = [];

  const inseam = profile.inseam_cm || 0;
  const starter = saddleStarterFromInseam(inseam);

  // 0) Profil
  if(profile.height_cm || profile.inseam_cm){
    out.push({lvl:"ok", title:"Profil zapisany",
      why:`Styl: ${profile.style.toUpperCase()}, wzrost: ${profile.height_cm||"-"} cm, przekrok: ${profile.inseam_cm||"-"} cm.`,
      do: starter ? `Punkt startowy (orientacyjnie): wysokość siodła ~ ${starter.toFixed(1)} cm (metoda 0.883). To tylko baza do dalszych testów.` :
                    `Jeśli podasz przekrok, podpowiem orientacyjną wysokość startową siodła.`});
  }

  // 1) Siodło: kolano + rocking
  if(Number.isFinite(sideMetrics.knee)){
    const knee = sideMetrics.knee;
    const deltaHigh = knee - t.kneeBDP[1]; // dodatni = za prosto
    const deltaLow  = t.kneeBDP[0] - knee; // dodatni = za mocno ugięte
    const mmHigh = stepMmFromDelta(deltaHigh);
    const mmLow  = stepMmFromDelta(deltaLow);

    if(knee > t.kneeBDP[1] && Number.isFinite(rearMetrics.rocking) && rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"bad", title:"Siodło prawdopodobnie za wysoko",
        why:`Kolano w BDP ~ ${knee.toFixed(1)}° (powyżej ${t.kneeBDP[1]}°) + rocking ${rearMetrics.rocking.toFixed(3)} (wysoki).`,
        do:`Obniż siodło o ${mmHigh||5} mm i zrób re-test (10–20 obrotów). Jeśli dalej buja, kolejne -${mmHigh||5} mm.`});
    } else if(knee > t.kneeBDP[1]){
      out.push({lvl:"warn", title:"Możliwe: siodło za wysoko",
        why:`Kolano w BDP ~ ${knee.toFixed(1)}° (cel: ${t.kneeBDP[0]}–${t.kneeBDP[1]}°).`,
        do:`Test: obniż siodło o ${mmHigh||3} mm, potem sprawdź komfort i rocking.`});
    } else if(knee < t.kneeBDP[0]){
      out.push({lvl:"warn", title:"Możliwe: siodło za nisko",
        why:`Kolano w BDP ~ ${knee.toFixed(1)}° (poniżej ${t.kneeBDP[0]}°).`,
        do:`Test: podnieś siodło o ${mmLow||3} mm i powtórz pomiar.`});
    } else {
      out.push({lvl:"ok", title:"Wysokość siodła wygląda OK (wg kolana)",
        why:`Kolano w BDP ~ ${knee.toFixed(1)}° w zakresie ${t.kneeBDP[0]}–${t.kneeBDP[1]}°.`,
        do:`Dalej oceniamy przód (reach/drop) i stabilność z tyłu.`});
    }
  } else {
    out.push({lvl:"warn", title:"Brak metryki kolana (BOK)",
      why:"Nie wykryto hip/knee/ankle.", do:"Sprawdź markery i światło."});
  }

  // 2) Reach / mostek: łokieć
  if(Number.isFinite(sideMetrics.elbow)){
    const e = sideMetrics.elbow;
    if(e > t.elbow[1]){
      const d = e - t.elbow[1];
      out.push({lvl:"warn", title:"Za proste ręce / możliwie za duży reach",
        why:`Kąt łokcia ~ ${e.toFixed(1)}° (powyżej ${t.elbow[1]}°).`,
        do:`Test A: krótszy mostek o 10 mm. Test B: podnieś kokpit 5–10 mm. Wybierz 1 zmianę i re-test.`});
    } else if(e < t.elbow[0]){
      out.push({lvl:"warn", title:"Bardzo ugięte łokcie / pozycja mocno “zebrana”",
        why:`Kąt łokcia ~ ${e.toFixed(1)}° (poniżej ${t.elbow[0]}°).`,
        do:`Jeśli to nie aero: dłuższy mostek (+10 mm) lub niżej uchwyty/zmiana chwytu. Re-test.`});
    } else {
      out.push({lvl:"ok", title:"Łokieć wygląda OK",
        why:`Kąt łokcia ~ ${e.toFixed(1)}° w zakresie ${t.elbow[0]}–${t.elbow[1]}°.`,
        do:"OK."});
    }
  }

  // 3) Stabilność tył
  if(Number.isFinite(rearMetrics.rocking)){
    if(rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"warn", title:"Rocking miednicy podwyższony",
        why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)} (powyżej ${t.rockingMax}).`,
        do:`Najczęściej: minimalnie za wysoko siodło lub zbyt agresywny przód. Testuj jedną zmianę naraz.`});
    } else {
      out.push({lvl:"ok", title:"Stabilność miednicy OK",
        why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)} (<= ${t.rockingMax}).`,
        do:"OK."});
    }
  }

  // 4) Setback / sztyca (heurystyka v1 – prosta)
  out.push({lvl:"ok", title:"Setback / sztyca (v1 – heurystyka)",
    why:"W tej wersji setback podpowiadamy dopiero po dodaniu markera kolana względem osi pedału (KOPS) lub po modelu 3D.",
    do:"W kolejnej wersji dołożymy KOPS i wtedy: setback / sztyca z offsetem będą bardziej precyzyjne."});

  return out;
}

/** =========================
 *  UI + WebSocket + metryki
 *  ========================= */
const els = {
  mode: document.getElementById("mode"),
  status: document.getElementById("status"),
  cams: document.getElementById("cams"),
  room: document.getElementById("room"),
  wsUrl: document.getElementById("wsUrl"),
  btnConnect: document.getElementById("btnConnect"),
  btnStart: document.getElementById("btnStart"),
  btnStop: document.getElementById("btnStop"),
  style: document.getElementById("style"),
  height: document.getElementById("height"),
  inseam: document.getElementById("inseam"),
  cardCam: document.getElementById("cardCam"),
  camTitle: document.getElementById("camTitle"),
  rolePill: document.getElementById("rolePill"),
  btnSwitchCam: document.getElementById("btnSwitchCam"),
  v: document.getElementById("v"),
  c: document.getElementById("c"),
  camOut: document.getElementById("camOut"),
  sideCanvas: document.getElementById("sideCanvas"),
  rearCanvas: document.getElementById("rearCanvas"),
  sideOut: document.getElementById("sideOut"),
  rearOut: document.getElementById("rearOut"),
  reco: document.getElementById("reco"),
  cardDemo: document.getElementById("cardDemo"),
  demoJson: document.getElementById("demoJson"),
  btnDemoGood: document.getElementById("btnDemoGood"),
  btnDemoBadSaddle: document.getElementById("btnDemoBadSaddle"),
  btnDemoBadReach: document.getElementById("btnDemoBadReach"),
  kpiKnee: document.getElementById("kpiKnee"),
  kpiElbow: document.getElementById("kpiElbow"),
  kpiRock: document.getElementById("kpiRock"),
  btnNewSession: document.getElementById("btnNewSession"),
  btnSnap: document.getElementById("btnSnap"),
  btnExport: document.getElementById("btnExport"),
  sessionInfo: document.getElementById("sessionInfo"),
  sessionId: document.getElementById("sessionId"),
  sessionList: document.getElementById("sessionList"),
};

els.wsUrl.value = `ws://${location.hostname || "127.0.0.1"}:8181`;

let ws = null;
let running = false;

let sidePoints = null;
let rearPoints = null;

function setStatus(text, ok){
  els.status.textContent = text;
  els.status.style.borderColor = ok ? "#2a6a3a" : "#6a2a2a";
}
function setCams(online){
  els.cams.textContent = `SIDE: ${online.side ? "ON" : "-"} | REAR: ${online.rear ? "ON" : "-"}`;
}

function profile(){
  return {
    style: els.style.value,
    height_cm: Number(els.height.value||0),
    inseam_cm: Number(els.inseam.value||0)
  };
}

function renderReco(sideMetrics, rearMetrics){
  const items = recommendations(profile(), sideMetrics, rearMetrics);
  els.reco.innerHTML = items.map(it => `
    <div class="item ${it.lvl}">
      <div><b>${it.title}</b></div>
      <div><small>${it.why}</small></div>
      <div>${it.do}</div>
    </div>
  `).join("");
  return items;
}

function computeSideMetrics(points){
  const m = { knee: NaN, hip: NaN, elbow: NaN };
  if(points?.hip && points?.knee && points?.ankle) m.knee = angle3(points.hip, points.knee, points.ankle);
  if(points?.shoulder && points?.hip && points?.knee) m.hip = angle3(points.shoulder, points.hip, points.knee);
  if(points?.shoulder && points?.elbow && points?.wrist) m.elbow = angle3(points.shoulder, points.elbow, points.wrist);
  return m;
}

let rearHistory = [];
function computeRearMetrics(points){
  const m = { rocking: NaN, pelvisTilt: NaN, shoulderTilt: NaN };

  if(points?.l_pelvis && points?.r_pelvis){
    m.pelvisTilt = points.l_pelvis.y - points.r_pelvis.y;
  }
  if(points?.l_shoulder && points?.r_shoulder){
    m.shoulderTilt = points.l_shoulder.y - points.r_shoulder.y;
  }

  if(points?.l_pelvis && points?.r_pelvis && points?.l_shoulder && points?.r_shoulder){
    const pelvisMid = { x:(points.l_pelvis.x+points.r_pelvis.x)/2, y:(points.l_pelvis.y+points.r_pelvis.y)/2 };
    const shoulderMid= { x:(points.l_shoulder.x+points.r_shoulder.x)/2, y:(points.l_shoulder.y+points.r_shoulder.y)/2 };
    const torsoH = Math.max(50, Math.abs(pelvisMid.y - shoulderMid.y));
    const tiltNorm = Math.abs(m.pelvisTilt) / torsoH;
    rearHistory.push(tiltNorm);
    if(rearHistory.length>120) rearHistory.shift();
    const max = Math.max(...rearHistory);
    const min = Math.min(...rearHistory);
    m.rocking = (max - min);
  }
  return m;
}

function drawPointsTo(canvas, points, title){
  const ctx = canvas.getContext("2d");
  canvas.width = 640; canvas.height = 360;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 2;
  ctx.font = "14px system-ui";
  ctx.strokeStyle = "#fff";
  ctx.fillStyle = "#fff";
  ctx.fillText(title, 10, 20);

  if(!points){
    ctx.fillText("brak punktów", 10, 45);
    return;
  }
  for(const [k,p] of Object.entries(points)){
    if(!p) continue;
    const x = p.x * 0.5;
    const y = p.y * 0.5;
    ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.stroke();
    ctx.fillText(k, x+8, y);
  }
}

function setKpi(sideM, rearM){
  els.kpiKnee.textContent = `Kolano: ${Number.isFinite(sideM.knee) ? sideM.knee.toFixed(1)+"°" : "-"}`;
  els.kpiElbow.textContent = `Łokieć: ${Number.isFinite(sideM.elbow) ? sideM.elbow.toFixed(1)+"°" : "-"}`;
  els.kpiRock.textContent = `Rocking: ${Number.isFinite(rearM.rocking) ? rearM.rocking.toFixed(3) : "-"}`;
}

/** =========== Sesja =========== */
let session = {
  id: null,
  createdAt: null,
  snaps: []
};
function newSession(){
  session = {
    id: `S-${Math.random().toString(16).slice(2,8)}-${Date.now().toString(16).slice(-6)}`.toUpperCase(),
    createdAt: new Date().toISOString(),
    snaps: []
  };
  renderSession();
}
function renderSession(){
  els.sessionInfo.textContent = `SNAP: ${session.snaps.length}`;
  els.sessionId.textContent = `ID: ${session.id || "-"}`;
  els.sessionList.innerHTML = session.snaps.map((s,idx)=>`
    <div class="snap">
      <div class="snapHeader">
        <div><b>SNAP #${idx+1}</b> <span class="tag">${new Date(s.t).toLocaleString()}</span></div>
        <div class="tag">${s.profile.style.toUpperCase()}</div>
      </div>
      <div class="muted">Kolano: ${Number.isFinite(s.side.knee)?s.side.knee.toFixed(1)+"°":"-"} |
        Łokieć: ${Number.isFinite(s.side.elbow)?s.side.elbow.toFixed(1)+"°":"-"} |
        Rocking: ${Number.isFinite(s.rear.rocking)?s.rear.rocking.toFixed(3):"-"}</div>
      <details>
        <summary>Rekomendacje (${s.reco.length})</summary>
        <div style="margin-top:8px">${s.reco.map(r=>`<div class="item ${r.lvl}"><b>${r.title}</b><div class="muted">${r.why}</div><div>${r.do}</div></div>`).join("")}</div>
      </details>
    </div>
  `).join("");
}
function downloadJson(filename, obj){
  const blob = new Blob([JSON.stringify(obj,null,2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}
els.btnNewSession.onclick = () => newSession();
els.btnSnap.onclick = () => {
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);
  const recoItems = recommendations(profile(), sideM, rearM);

  session.snaps.push({
    t: new Date().toISOString(),
    profile: profile(),
    side: sideM,
    rear: rearM,
    points: { side: sidePoints, rear: rearPoints },
    reco: recoItems
  });
  renderSession();
};
els.btnExport.onclick = () => {
  if(!session.id) newSession();
  downloadJson(`${session.id}.json`, session);
};

/** =========================
 *  HUB update
 *  ========================= */
function updateHubUI(){
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);

  drawPointsTo(els.sideCanvas, sidePoints, "BOK (punkty)");
  drawPointsTo(els.rearCanvas, rearPoints, "TYŁ (punkty)");

  els.sideOut.textContent =
    JSON.stringify({points: sidePoints, metrics: sideM}, null, 2);
  els.rearOut.textContent =
    JSON.stringify({points: rearPoints, metrics: rearM}, null, 2);

  setKpi(sideM, rearM);
  renderReco(sideM, rearM);
}

/** =========== WebSocket =========== */
function connectWS(){
  const url = els.wsUrl.value.trim();
  if(!url) return alert("Podaj WS URL (np. ws://IP:8181)");
  ws = new WebSocket(url);

  ws.onopen = () => {
    setStatus("ONLINE", true);
    ws.send(JSON.stringify({type:"join", room: els.room.value.trim()||"default", role: currentRole()}));
  };
  ws.onclose = () => setStatus("OFFLINE", false);
  ws.onerror = () => setStatus("ERROR", false);

  ws.onmessage = (ev) => {
    let msg; try{ msg = JSON.parse(ev.data);}catch{ return; }
    if(msg.type==="status"){ setCams(msg.online||{side:false,rear:false}); }
    if(msg.type==="points"){
      if(msg.role==="side") sidePoints = msg.points;
      if(msg.role==="rear") rearPoints = msg.points;
      if(els.mode.value==="hub") updateHubUI();
    }
    if(msg.type==="cmd"){
      if(msg.cmd==="start"){ running = true; camLoop(); }
      if(msg.cmd==="stop"){ running = false; }
    }
  };
}
function sendCmd(cmd){
  if(ws && ws.readyState===1){
    ws.send(JSON.stringify({type:"cmd", room: els.room.value.trim()||"default", cmd}));
  }
}

/** =========== Kamera =========== */
let stream = null;
let facing = "environment";
const ctx = els.c.getContext("2d", { willReadFrequently: true });

async function startCamera(){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: facing, width:{ideal:1280}, height:{ideal:720} },
    audio: false
  });
  els.v.srcObject = stream;
}

function currentRole(){
  if(els.mode.value==="hub") return "hub";
  if(els.mode.value==="cam_side") return "side";
  if(els.mode.value==="cam_rear") return "rear";
  return "hub";
}

function detectPoints(role, img, w, h){
  if(role==="side"){
    return {
      hip:   findCentroid(img,w,h,HSV.neonGreen),
      knee:  findCentroid(img,w,h,HSV.pinkWrap),
      ankle: findCentroid(img,w,h,HSV.cyan),
      shoulder: findCentroid(img,w,h,HSV.orange),
      elbow:    findCentroid(img,w,h,HSV.yellow),
      wrist:    findCentroid(img,w,h,HSV.purple),
    };
  }
  return {
    l_shoulder: findCentroid(img,w,h,HSV.orange),
    r_shoulder: findCentroid(img,w,h,HSV.yellow),
    l_pelvis:   findCentroid(img,w,h,HSV.neonGreen),
    r_pelvis:   findCentroid(img,w,h,HSV.pinkWrap),
  };
}

function camLoop(){
  const role = currentRole();
  if(!(role==="side"||role==="rear")) return;
  if(!running) return;

  if(!els.v.videoWidth){ requestAnimationFrame(camLoop); return; }

  const w = els.v.videoWidth, h = els.v.videoHeight;
  els.c.width = w; els.c.height = h;
  ctx.drawImage(els.v,0,0,w,h);
  const img = ctx.getImageData(0,0,w,h);
  const pts = detectPoints(role, img, w, h);

  ctx.lineWidth = 3; ctx.font = "16px system-ui";
  for(const [k,p] of Object.entries(pts)){
    if(!p) continue;
    drawDot(ctx, p, k);
  }

  const payload = {};
  for(const [k,p] of Object.entries(pts)){
    payload[k] = p ? {x:p.x, y:p.y} : null;
  }
  els.camOut.textContent = JSON.stringify(payload, null, 2);

  if(ws && ws.readyState===1){
    ws.send(JSON.stringify({type:"points", t: performance.now(), role, points: payload}));
  }

  requestAnimationFrame(camLoop);
}

/** ======= DEMO (bez kamer) ======= */
let demoState = { side: null, rear: null };
function setDemo(state){
  demoState = state;
  els.demoJson.textContent = JSON.stringify(demoState, null, 2);
  sidePoints = demoState.side;
  rearPoints = demoState.rear;
  updateHubUI();
}
els.btnDemoGood.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
});
els.btnDemoBadSaddle.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:600,y:520}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:340}, r_pelvis:{x:500,y:390} }
});
els.btnDemoBadReach.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:230,y:210}, wrist:{x:150,y:220} },
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
});

/** ======= UI zachowanie ======= */
function applyMode(){
  const m = els.mode.value;
  const isCam = (m==="cam_side" || m==="cam_rear");
  const isHub = (m==="hub");
  const isDemo= (m==="demo");

  els.cardCam.style.display = isCam ? "" : "none";
  els.cardSide.style.display = isHub || isDemo ? "" : "none";
  els.cardRear.style.display = isHub || isDemo ? "" : "none";
  els.cardDemo.style.display = isDemo ? "" : "none";

  if(isCam){
    els.rolePill.textContent = `ROLE: ${m==="cam_side" ? "SIDE" : "REAR"}`;
    els.camTitle.textContent = `Kamera ${m==="cam_side" ? "BOK" : "TYŁ"}`;
  }
}
els.mode.onchange = applyMode;
applyMode();

els.btnConnect.onclick = () => connectWS();
els.btnStart.onclick = () => { running = true; sendCmd("start"); camLoop(); };
els.btnStop.onclick = () => { running = false; sendCmd("stop"); };

els.btnSwitchCam.onclick = async () => {
  facing = (facing==="environment") ? "user" : "environment";
  try{ await startCamera(); }catch(e){ alert("Nie mogę uruchomić kamery: " + e.message); }
};

// auto start
(async () => {
  if(!session.id) newSession();

  if(els.mode.value.startsWith("cam")){
    try{ await startCamera(); }catch{}
  }
  setDemo({
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
  });
})();
</script>
</body>
</html>
