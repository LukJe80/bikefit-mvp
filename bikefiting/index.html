<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bikefit MVP (BOK + TYŁ) – 1 plik</title>
<style>
  body{margin:0;font-family:system-ui,Arial;background:#0b0b0c;color:#fff}
  header{padding:12px 16px;background:#141416;border-bottom:1px solid #26262a}
  h1{margin:0 0 8px 0;font-size:18px}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:8px 0}
  input,select,button{padding:8px;border-radius:10px;border:1px solid #333;background:#0f0f11;color:#fff}
  input{width:150px}
  button{cursor:pointer}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #333;background:#0f0f11}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;padding:12px}
  .card{background:#141416;border:1px solid #26262a;border-radius:12px;padding:12px}
  .full{grid-column:1/-1}
  video,canvas{width:100%;border-radius:12px;background:#000;margin-top:8px}
  pre{white-space:pre-wrap;background:#0f0f11;padding:8px;border-radius:10px;border:1px solid #26262a;max-height:220px;overflow:auto}
  #reco .item{padding:10px;border:1px solid #2a2a2f;border-radius:12px;margin:8px 0;background:#101014}
  #reco .bad{border-color:#6a2a2a}
  #reco .warn{border-color:#6a5a2a}
  #reco .ok{border-color:#2a6a3a}
  small{opacity:.8}
</style>
</head>
<body>
<header>
  <h1>Bikefit MVP (BOK + TYŁ) – 1 plik</h1>

  <div class="row">
    <label>Tryb:</label>
    <select id="mode">
      <option value="hub">HUB (Laptop)</option>
      <option value="cam_side">CAM – BOK (Telefon)</option>
      <option value="cam_rear">CAM – TYŁ (Telefon)</option>
      <option value="demo">DEMO (bez kamer)</option>
    </select>
    <span id="status" class="pill">OFFLINE</span>
    <span id="cams" class="pill">SIDE: - | REAR: -</span>
  </div>

  <div class="row">
    <label>Room:</label><input id="room" value="default"/>
    <label>WS URL:</label><input id="wsUrl" placeholder="ws://IP:8181"/>
    <button id="btnConnect">Połącz</button>
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
  </div>

  <div class="row">
    <label>Styl:</label>
    <select id="style">
      <option value="road">Szosa</option>
      <option value="mtb">MTB</option>
    </select>
    <label>Wzrost (cm):</label><input id="height" type="number" value="175"/>
    <label>Przekrok (cm):</label><input id="inseam" type="number" value="82"/>
    <small>Tip: przekrok = od kroku do ziemi (książka + ściana).</small>
  </div>
</header>

<main class="grid">
  <section class="card" id="cardCam">
    <h2 id="camTitle">Kamera</h2>
    <div class="row">
      <button id="btnSwitchCam">Przełącz kamerę</button>
      <span class="pill" id="rolePill">ROLE: -</span>
    </div>
    <video id="v" playsinline autoplay muted></video>
    <canvas id="c"></canvas>
    <pre id="camOut"></pre>
  </section>

  <section class="card" id="cardSide">
    <h2>BOK – metryki</h2>
    <canvas id="sideCanvas"></canvas>
    <pre id="sideOut"></pre>
  </section>

  <section class="card" id="cardRear">
    <h2>TYŁ – metryki</h2>
    <canvas id="rearCanvas"></canvas>
    <pre id="rearOut"></pre>
  </section>

  <section class="card full">
    <h2>Rekomendacje</h2>
    <div id="reco"></div>
    <small>
      Uwaga: v1 to rekomendacje krokowe (np. 3–5 mm, 5–10 mm, 10 mm) + re-test.
    </small>
  </section>

  <section class="card full" id="cardDemo">
    <h2>DEMO – ręczne punkty (bez kamer)</h2>
    <small>Możesz tu wkleić punkty i sprawdzić, czy rekomendacje działają zanim odpalisz kamery.</small>
    <pre id="demoJson"></pre>
    <button id="btnDemoGood">Wstaw “OK”</button>
    <button id="btnDemoBadSaddle">Wstaw “siodło za wysoko”</button>
    <button id="btnDemoBadReach">Wstaw “za długi reach”</button>
  </section>
</main>

<script>
/** =========================
 *  HSV + markery (do dopasowania pod Twoje naklejki)
 *  ========================= */
const HSV = {
  neonGreen: { h1: 45,  h2: 95,  s: 120, v: 80 },
  cyan:      { h1: 170, h2: 210, s: 120, v: 80 },
  orange:    { h1: 15,  h2: 40,  s: 120, v: 80 },
  yellow:    { h1: 40,  h2: 70,  s: 120, v: 80 },
  purple:    { h1: 250, h2: 300, s: 110, v: 70 },
  pinkWrap:  { h1: 300, h2: 360, s: 120, v: 80, wrap: true, h3: 0, h4: 20 }
};

function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  const d=max-min;
  let h=0;
  if(d!==0){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max===0?0:d/max;
  const v=max;
  return {h, s:s*255, v:v*255};
}
function inPreset(hsv,p){
  if(hsv.s<p.s || hsv.v<p.v) return false;
  if(p.wrap){
    return (hsv.h>=p.h1 && hsv.h<=p.h2) || (hsv.h>=p.h3 && hsv.h<=p.h4);
  }
  return hsv.h>=p.h1 && hsv.h<=p.h2;
}
function findCentroid(imageData, w, h, preset){
  const data=imageData.data;
  let sx=0, sy=0, c=0;
  for(let y=0;y<h;y+=2){
    for(let x=0;x<w;x+=2){
      const i=(y*w+x)*4;
      const hsv=rgbToHsv(data[i],data[i+1],data[i+2]);
      if(inPreset(hsv,preset)){ sx+=x; sy+=y; c++; }
    }
  }
  if(c<60) return null;
  return {x:sx/c, y:sy/c, n:c};
}
function angle3(a,b,c){
  if(!a||!b||!c) return NaN;
  const ba={x:a.x-b.x, y:a.y-b.y};
  const bc={x:c.x-b.x, y:c.y-b.y};
  const dot=ba.x*bc.x+ba.y*bc.y;
  const nba=Math.hypot(ba.x,ba.y);
  const nbc=Math.hypot(bc.x,bc.y);
  const cos=dot/(nba*nbc+1e-9);
  const v=Math.max(-1,Math.min(1,cos));
  return Math.acos(v)*180/Math.PI;
}
function drawDot(ctx,p,label){
  if(!p) return;
  ctx.beginPath(); ctx.arc(p.x,p.y,8,0,Math.PI*2); ctx.stroke();
  ctx.fillText(label,p.x+10,p.y);
}

/** =========================
 *  Rekomendacje (v1 – heurystyki)
 *  ========================= */
function makeTargets(style){
  // progi mocno uproszczone na MVP (ustawimy dokładniej po testach)
  // angle3 daje "kąt w stawie" (wewnętrzny) – im większy, tym bardziej wyprostowane
  return style==="road"
    ? { kneeBDP: [145, 160], elbow: [150, 175], rockingMax: 0.035 }
    : { kneeBDP: [140, 158], elbow: [155, 178], rockingMax: 0.045 };
}

function recommendations(profile, sideMetrics, rearMetrics){
  const t = makeTargets(profile.style);
  const out = [];

  // 1) Siodło: kolano + rocking
  if(Number.isFinite(sideMetrics.knee)){
    if(sideMetrics.knee > t.kneeBDP[1] && rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"bad", title:"Siodło prawdopodobnie za wysoko",
        why:`Kolano w BDP ~ ${sideMetrics.knee.toFixed(1)}° (za prosto) + rocking ${rearMetrics.rocking.toFixed(3)} (wysoki).`,
        do:`Obniż siodło o 3–5 mm i zrób re-test (10–20 obrotów).`});
    } else if(sideMetrics.knee > t.kneeBDP[1]){
      out.push({lvl:"warn", title:"Możliwe: siodło za wysoko",
        why:`Kolano w BDP ~ ${sideMetrics.knee.toFixed(1)}° (powyżej zakresu).`,
        do:`Spróbuj obniżyć 3 mm i sprawdź rocking / komfort.`});
    } else if(sideMetrics.knee < t.kneeBDP[0]){
      out.push({lvl:"warn", title:"Możliwe: siodło za nisko",
        why:`Kolano w BDP ~ ${sideMetrics.knee.toFixed(1)}° (mocno ugięte).`,
        do:`Podnieś siodło o 3–5 mm i powtórz pomiar.`});
    } else {
      out.push({lvl:"ok", title:"Wysokość siodła wygląda OK (wg kolana)",
        why:`Kolano w BDP ~ ${sideMetrics.knee.toFixed(1)}° w zakresie.`,
        do:`Dalej oceniamy przód (reach/drop) i stabilność z tyłu.`});
    }
  } else {
    out.push({lvl:"warn", title:"Brak metryki kolana (BOK)", why:"Nie wykryto hip/knee/ankle.", do:"Sprawdź markery i światło."});
  }

  // 2) Reach / mostek: łokieć
  if(Number.isFinite(sideMetrics.elbow)){
    if(sideMetrics.elbow > t.elbow[1]){
      out.push({lvl:"warn", title:"Za proste ręce / możliwie za duży reach",
        why:`Kąt łokcia ~ ${sideMetrics.elbow.toFixed(1)}° (prawie prosta ręka).`,
        do:`Test: krótszy mostek o 10 mm lub wyżej kokpit (5–10 mm).`});
    } else if(sideMetrics.elbow < t.elbow[0]){
      out.push({lvl:"warn", title:"Bardzo ugięte łokcie / pozycja mocno “zebrana”",
        why:`Kąt łokcia ~ ${sideMetrics.elbow.toFixed(1)}° (mocno ugięte).`,
        do:`Sprawdź czy to zamierzone (aero) – jeśli nie: dłuższy mostek lub niżej łokcie/ustawienie chwytu.`});
    } else {
      out.push({lvl:"ok", title:"Łokieć wygląda OK", why:`Kąt łokcia ~ ${sideMetrics.elbow.toFixed(1)}° w zakresie.`, do:"OK."});
    }
  }

  // 3) Stabilność tył
  if(Number.isFinite(rearMetrics.rocking)){
    if(rearMetrics.rocking > t.rockingMax){
      out.push({lvl:"warn", title:"Rocking miednicy podwyższony",
        why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)} (powyżej progu).`,
        do:`Najczęściej: minimalnie za wysoko siodło lub zbyt agresywny przód. Testuj jedną zmianę naraz.`});
    } else {
      out.push({lvl:"ok", title:"Stabilność miednicy OK", why:`Rocking ~ ${rearMetrics.rocking.toFixed(3)}.`, do:"OK."});
    }
  }

  // 4) Przekrok: sugestia startowa (tylko informacyjnie)
  if(profile.inseam_cm){
    const inseam = profile.inseam_cm;
    // Uproszczony “starter”: pokazujemy tylko, że przekrok jest w profilu.
    out.push({lvl:"ok", title:"Profil antropometryczny zapisany",
      why:`Wzrost ${profile.height_cm} cm, przekrok ${inseam} cm, styl ${profile.style.toUpperCase()}.`,
      do:`Te dane wykorzystamy w kolejnej wersji do dokładniejszego skalowania zaleceń (mm) i presetów.`});
  }

  return out;
}

/** =========================
 *  UI + WebSocket + metryki
 *  ========================= */
const els = {
  mode: document.getElementById("mode"),
  status: document.getElementById("status"),
  cams: document.getElementById("cams"),
  room: document.getElementById("room"),
  wsUrl: document.getElementById("wsUrl"),
  btnConnect: document.getElementById("btnConnect"),
  btnStart: document.getElementById("btnStart"),
  btnStop: document.getElementById("btnStop"),
  style: document.getElementById("style"),
  height: document.getElementById("height"),
  inseam: document.getElementById("inseam"),
  cardCam: document.getElementById("cardCam"),
  camTitle: document.getElementById("camTitle"),
  rolePill: document.getElementById("rolePill"),
  btnSwitchCam: document.getElementById("btnSwitchCam"),
  v: document.getElementById("v"),
  c: document.getElementById("c"),
  camOut: document.getElementById("camOut"),
  sideCanvas: document.getElementById("sideCanvas"),
  rearCanvas: document.getElementById("rearCanvas"),
  sideOut: document.getElementById("sideOut"),
  rearOut: document.getElementById("rearOut"),
  reco: document.getElementById("reco"),
  cardDemo: document.getElementById("cardDemo"),
  demoJson: document.getElementById("demoJson"),
  btnDemoGood: document.getElementById("btnDemoGood"),
  btnDemoBadSaddle: document.getElementById("btnDemoBadSaddle"),
  btnDemoBadReach: document.getElementById("btnDemoBadReach"),
};

els.wsUrl.value = `ws://${location.hostname || "127.0.0.1"}:8181`;

let ws = null;
let running = false;

let sidePoints = null;
let rearPoints = null;

function setStatus(text, ok){
  els.status.textContent = text;
  els.status.style.borderColor = ok ? "#2a6a3a" : "#6a2a2a";
}
function setCams(online){
  els.cams.textContent = `SIDE: ${online.side ? "ON" : "-"} | REAR: ${online.rear ? "ON" : "-"}`;
}

function profile(){
  return {
    style: els.style.value,
    height_cm: Number(els.height.value||0),
    inseam_cm: Number(els.inseam.value||0)
  };
}

function renderReco(sideMetrics, rearMetrics){
  const items = recommendations(profile(), sideMetrics, rearMetrics);
  els.reco.innerHTML = items.map(it => `
    <div class="item ${it.lvl}">
      <div><b>${it.title}</b></div>
      <div><small>${it.why}</small></div>
      <div>${it.do}</div>
    </div>
  `).join("");
}

function computeSideMetrics(points){
  // points: {hip,knee,ankle,shoulder,elbow,wrist} or subset
  const m = { knee: NaN, hip: NaN, elbow: NaN };
  if(points?.hip && points?.knee && points?.ankle) m.knee = angle3(points.hip, points.knee, points.ankle);
  if(points?.shoulder && points?.hip && points?.knee) m.hip = angle3(points.shoulder, points.hip, points.knee);
  if(points?.shoulder && points?.elbow && points?.wrist) m.elbow = angle3(points.shoulder, points.elbow, points.wrist);
  return m;
}

let rearHistory = [];
function computeRearMetrics(points){
  // points: l_pelvis, r_pelvis, l_shoulder, r_shoulder
  // rocking: różnica wysokości miednicy (L-R) znormalizowana przez wysokość "tułowia" (barki->miednica)
  const m = { rocking: NaN, pelvisTilt: NaN, shoulderTilt: NaN };

  if(points?.l_pelvis && points?.r_pelvis){
    m.pelvisTilt = points.l_pelvis.y - points.r_pelvis.y; // px
  }
  if(points?.l_shoulder && points?.r_shoulder){
    m.shoulderTilt = points.l_shoulder.y - points.r_shoulder.y; // px
  }

  if(points?.l_pelvis && points?.r_pelvis && points?.l_shoulder && points?.r_shoulder){
    const pelvisMid = { x:(points.l_pelvis.x+points.r_pelvis.x)/2, y:(points.l_pelvis.y+points.r_pelvis.y)/2 };
    const shoulderMid= { x:(points.l_shoulder.x+points.r_shoulder.x)/2, y:(points.l_shoulder.y+points.r_shoulder.y)/2 };
    const torsoH = Math.max(50, Math.abs(pelvisMid.y - shoulderMid.y)); // px, zabezpieczenie
    const tiltNorm = Math.abs(m.pelvisTilt) / torsoH; // 0.00–0.10 typowo
    rearHistory.push(tiltNorm);
    if(rearHistory.length>120) rearHistory.shift(); // ~4 sek przy 30fps
    const max = Math.max(...rearHistory);
    const min = Math.min(...rearHistory);
    m.rocking = (max - min); // amplituda w oknie czasowym
  }
  return m;
}

function drawPointsTo(canvas, points, title){
  const ctx = canvas.getContext("2d");
  canvas.width = 640; canvas.height = 360;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.lineWidth = 2;
  ctx.font = "14px system-ui";
  ctx.strokeStyle = "#fff";
  ctx.fillStyle = "#fff";
  ctx.fillText(title, 10, 20);

  if(!points){
    ctx.fillText("brak punktów", 10, 45);
    return;
  }
  // skaluje punkty z “oryginalnego” wideo do canvas: tu nie znamy rozmiaru,
  // więc rysujemy tylko relacyjnie: zakładamy, że x,y są już w skali 0..w,0..h
  // W MVP wystarczy tekst + kropki w przybliżeniu.
  for(const [k,p] of Object.entries(points)){
    if(!p) continue;
    // Mapujemy proporcjonalnie: tu zakładamy max 1280x720 -> 640x360
    const x = p.x * 0.5;
    const y = p.y * 0.5;
    ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.stroke();
    ctx.fillText(k, x+8, y);
  }
}

function updateHubUI(){
  const sideM = computeSideMetrics(sidePoints);
  const rearM = computeRearMetrics(rearPoints);

  drawPointsTo(els.sideCanvas, sidePoints, "BOK (punkty)");
  drawPointsTo(els.rearCanvas, rearPoints, "TYŁ (punkty)");

  els.sideOut.textContent =
    JSON.stringify({points: sidePoints, metrics: sideM}, null, 2);
  els.rearOut.textContent =
    JSON.stringify({points: rearPoints, metrics: rearM}, null, 2);

  renderReco(sideM, rearM);
}

/** =========== WebSocket =========== */
function connectWS(){
  const url = els.wsUrl.value.trim();
  if(!url) return alert("Podaj WS URL (np. ws://IP:8181)");
  ws = new WebSocket(url);

  ws.onopen = () => {
    setStatus("ONLINE", true);
    ws.send(JSON.stringify({type:"join", room: els.room.value.trim()||"default", role: currentRole()}));
  };
  ws.onclose = () => setStatus("OFFLINE", false);
  ws.onerror = () => setStatus("ERROR", false);

  ws.onmessage = (ev) => {
    let msg; try{ msg = JSON.parse(ev.data);}catch{ return; }
    if(msg.type==="status"){ setCams(msg.online||{side:false,rear:false}); }
    if(msg.type==="points"){
      if(msg.role==="side") sidePoints = msg.points;
      if(msg.role==="rear") rearPoints = msg.points;
      if(els.mode.value==="hub") updateHubUI();
    }
    if(msg.type==="cmd"){
      if(msg.cmd==="start"){ running = true; camLoop(); }
      if(msg.cmd==="stop"){ running = false; }
    }
  };
}
function sendCmd(cmd){
  if(ws && ws.readyState===1){
    ws.send(JSON.stringify({type:"cmd", room: els.room.value.trim()||"default", cmd}));
  }
}

/** =========== Kamera =========== */
let stream = null;
let facing = "environment";
const ctx = els.c.getContext("2d", { willReadFrequently: true });

async function startCamera(){
  if(stream) stream.getTracks().forEach(t=>t.stop());
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: facing, width:{ideal:1280}, height:{ideal:720} },
    audio: false
  });
  els.v.srcObject = stream;
}

function currentRole(){
  if(els.mode.value==="hub") return "hub";
  if(els.mode.value==="cam_side") return "side";
  if(els.mode.value==="cam_rear") return "rear";
  return "hub";
}

function detectPoints(role, img, w, h){
  // DOPASUJ kolory do naklejek:
  if(role==="side"){
    return {
      hip:   findCentroid(img,w,h,HSV.neonGreen),
      knee:  findCentroid(img,w,h,HSV.pinkWrap),
      ankle: findCentroid(img,w,h,HSV.cyan),
      shoulder: findCentroid(img,w,h,HSV.orange),
      elbow:    findCentroid(img,w,h,HSV.yellow),
      wrist:    findCentroid(img,w,h,HSV.purple),
    };
  }
  // rear
  return {
    l_shoulder: findCentroid(img,w,h,HSV.orange),
    r_shoulder: findCentroid(img,w,h,HSV.yellow),
    l_pelvis:   findCentroid(img,w,h,HSV.neonGreen),
    r_pelvis:   findCentroid(img,w,h,HSV.pinkWrap),
  };
}

function camLoop(){
  const role = currentRole();
  if(!(role==="side"||role==="rear")) return;
  if(!running) return;

  if(!els.v.videoWidth){ requestAnimationFrame(camLoop); return; }

  const w = els.v.videoWidth, h = els.v.videoHeight;
  els.c.width = w; els.c.height = h;
  ctx.drawImage(els.v,0,0,w,h);
  const img = ctx.getImageData(0,0,w,h);
  const pts = detectPoints(role, img, w, h);

  // overlay
  ctx.lineWidth = 3; ctx.font = "16px system-ui";
  for(const [k,p] of Object.entries(pts)){
    if(!p) continue;
    drawDot(ctx, p, k);
  }

  // wysyłamy tylko x,y
  const payload = {};
  for(const [k,p] of Object.entries(pts)){
    payload[k] = p ? {x:p.x, y:p.y} : null;
  }
  els.camOut.textContent = JSON.stringify(payload, null, 2);

  if(ws && ws.readyState===1){
    ws.send(JSON.stringify({type:"points", t: performance.now(), points: payload}));
  }

  requestAnimationFrame(camLoop);
}

/** ======= DEMO (bez kamer) ======= */
let demoState = { side: null, rear: null };
function setDemo(state){
  demoState = state;
  els.demoJson.textContent = JSON.stringify(demoState, null, 2);
  sidePoints = demoState.side;
  rearPoints = demoState.rear;
  updateHubUI();
}
els.btnDemoGood.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
});
els.btnDemoBadSaddle.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:600,y:520}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} }, // “bardziej prosto”
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:340}, r_pelvis:{x:500,y:390} } // większy tilt -> rocking
});
els.btnDemoBadReach.onclick = () => setDemo({
  side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:230,y:210}, wrist:{x:150,y:220} }, // łokieć “prawie prosty”
  rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
});

/** ======= UI zachowanie ======= */
function applyMode(){
  const m = els.mode.value;
  const isCam = (m==="cam_side" || m==="cam_rear");
  const isHub = (m==="hub");
  const isDemo= (m==="demo");

  els.cardCam.style.display = isCam ? "" : "none";
  els.cardSide.style.display = isHub || isDemo ? "" : "none";
  els.cardRear.style.display = isHub || isDemo ? "" : "none";
  els.cardDemo.style.display = isDemo ? "" : "none";

  if(isCam){
    els.rolePill.textContent = `ROLE: ${m==="cam_side" ? "SIDE" : "REAR"}`;
    els.camTitle.textContent = `Kamera ${m==="cam_side" ? "BOK" : "TYŁ"}`;
  }
}
els.mode.onchange = applyMode;
applyMode();

els.btnConnect.onclick = () => connectWS();
els.btnStart.onclick = () => { running = true; sendCmd("start"); camLoop(); };
els.btnStop.onclick = () => { running = false; sendCmd("stop"); };

els.btnSwitchCam.onclick = async () => {
  facing = (facing==="environment") ? "user" : "environment";
  try{ await startCamera(); }catch(e){ alert("Nie mogę uruchomić kamery: " + e.message); }
};

// auto start kamery w trybie CAM
(async () => {
  if(els.mode.value.startsWith("cam")){
    try{ await startCamera(); }catch{}
  }
  // demo start
  setDemo({
    side: { hip:{x:400,y:300}, knee:{x:520,y:420}, ankle:{x:560,y:560}, shoulder:{x:320,y:180}, elbow:{x:260,y:240}, wrist:{x:220,y:280} },
    rear: { l_shoulder:{x:420,y:200}, r_shoulder:{x:520,y:200}, l_pelvis:{x:440,y:360}, r_pelvis:{x:500,y:362} }
  });
})();
</script>
</body>
</html>